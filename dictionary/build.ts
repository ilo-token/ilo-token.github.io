import { extractErrorMessage } from "../src/misc.ts";
import { parseDictionary } from "./parser.ts";

const SOURCE = new URL("./dictionary", import.meta.url);
const DESTINATION = new URL("./dictionary.ts", import.meta.url);

class ImportError extends Error {
  constructor(message?: string, options?: { cause: unknown }) {
    super(message, options);
    this.name = "ImportError";
  }
}
async function importPrevious(): Promise<string> {
  try {
    const { original } = await import("./dictionary.ts");
    return original;
  } catch (error) {
    throw new ImportError(extractErrorMessage(error), { cause: error });
  }
}
export async function build(checkFile: boolean): Promise<void> {
  const currentPromise = Deno.readTextFile(SOURCE);
  if (checkFile) {
    try {
      const [current, previous] = await Promise.all([
        currentPromise,
        importPrevious(),
      ]);
      if (current === previous) {
        return;
      }
    } catch (error) {
      if (!(error instanceof ImportError)) {
        throw error;
      }
    }
  }
  console.log("Building dictionary...");
  const text = await currentPromise;
  const json = JSON.stringify(
    Object.fromEntries(parseDictionary(text)),
    undefined,
    2,
  );
  const original = JSON.stringify(text);
  const code = `\
// This code is autogenerated

import { Dictionary } from "./type.ts";

export const dictionary: Dictionary = new Map(Object.entries(${json}));

export const original = ${original};
`;
  await Deno.writeTextFile(DESTINATION, code);
}
if (import.meta.main) {
  const checkFile = true;
  await build(checkFile);
}
