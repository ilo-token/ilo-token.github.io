// this code is Deno only

import { unreachable } from "@std/assert/unreachable";
import { extractResultError, ResultError } from "../compound.ts";
import { PositionedError } from "../parser/parser_lib.ts";
import { HEADS, parseDictionary } from "./parser.ts";
import { Dictionary } from "./type.ts";

const SOURCE = new URL("../../dictionary.txt", import.meta.url);
const DESTINATION = new URL("./global_dictionary.ts", import.meta.url);

export async function buildWithDictionary(
  dictionary: Dictionary,
): Promise<void> {
  const json = JSON.stringify(
    Object.fromEntries(dictionary),
    undefined,
    2,
  );
  const code = `\
// this code is autogenerated

import { Dictionary, Entry } from "./type.ts";

const json: Record<string, Entry> = ${json};

export const dictionary: Dictionary = new Map(Object.entries(json));
`;
  await Deno.writeTextFile(DESTINATION, code);
}
function buildOffloaded(src: string): Promise<Dictionary> {
  return new Promise((resolve, reject) => {
    const worker = new Worker(
      new URL("./worker.ts", import.meta.url),
      { type: "module" },
    );
    worker.postMessage(src);
    worker.onmessage = (event) => {
      resolve(event.data as Dictionary);
      worker.terminate();
    };
    worker.onerror = (event) => {
      reject(event.error);
    };
  });
}
export async function build(): Promise<boolean> {
  // deno-lint-ignore no-console
  console.log(
    `Building dictionary with ${navigator.hardwareConcurrency} threads...`,
  );
  const start = performance.now();
  const text = await Deno.readTextFile(SOURCE);
  const heads = [...text.matchAll(HEADS)].map((match) => match.index);
  const regionIndices = [...new Array(navigator.hardwareConcurrency).keys()]
    .map((index) => {
      const start = index * text.length / navigator.hardwareConcurrency;
      for (const head of heads) {
        if (start <= head) {
          return head;
        }
      }
    });
  const regions = regionIndices.map((index, i) =>
    text.slice(index, regionIndices[i + 1] ?? text.length)
  );
  const dictionary: Dictionary = new Map();
  try {
    const entries = await Promise.all(
      regions.map((region) => buildOffloaded(region)),
    );
    for (const entry of entries) {
      for (const [name, definition] of entry) {
        if (dictionary.has(name)) {
          throw new Error();
        }
        dictionary.set(name, definition);
      }
    }
  } catch (_) {
    try {
      parseDictionary(text);
    } catch (error) {
      displayError(`${SOURCE}`, extractResultError(error));
      return false;
    }
    unreachable();
  }
  await buildWithDictionary(dictionary);
  const end = performance.now();
  const total = Math.floor(end - start);
  // deno-lint-ignore no-console
  console.log(`Building dictionary done in ${total}ms`);
  return true;
}
function displayError(source: string, errors: ReadonlyArray<ResultError>) {
  let color: boolean;
  try {
    const noColor = Deno.env.get("NO_COLOR");
    color = noColor == null || noColor === "";
  } catch (error) {
    if (error instanceof Deno.errors.NotCapable) {
      color = true;
    } else {
      throw error;
    }
  }
  const red = color ? "color: red" : "";
  const sourceStyle = color ? "color: blue" : "";
  for (const error of errors) {
    // deno-lint-ignore no-console
    console.error(`%cError%c: ${error.message}`, red, "");
    if (error instanceof PositionedError && error.position != null) {
      const { position: { position, length } } = error;
      const end = position + length;
      // the only instance returning -1 is useful
      const startLine = source.lastIndexOf("\n", position) + 1;
      let currentLine = startLine;
      let currentPosition = position;

      while (true) {
        const index = source.indexOf("\n", currentLine);
        const nextLine = index === -1 ? source.length : index + 1;
        const line = source.slice(currentLine, nextLine).trimEnd();
        // deno-lint-ignore no-console
        console.error(line);
        let relativeStart = Math.min(
          currentPosition - currentLine,
          line.length,
        );
        let relativeEnd = Math.min(end - currentLine, line.length);
        if (relativeEnd - relativeStart === 0) {
          if (relativeStart !== 0) {
            relativeStart--;
          }
          if (relativeEnd !== line.length) {
            relativeEnd++;
          }
        }
        // deno-lint-ignore no-console
        console.error(
          `${" ".repeat(relativeStart)}%c${
            "^".repeat(relativeEnd - relativeStart)
          }`,
          red,
        );
        if (end <= nextLine) {
          break;
        } else {
          currentLine = currentPosition = nextLine;
        }
      }
      const line = source.slice(0, startLine).match(/\n/g)?.length ?? 1;
      const column = position - startLine + 1;
      // deno-lint-ignore no-console
      console.error(`    at %c${SOURCE}:${line}:${column}`, sourceStyle);
      // deno-lint-ignore no-console
      console.error();
    }
  }
}
if (import.meta.main) {
  Deno.exitCode = await build() ? 0 : 1;
}
