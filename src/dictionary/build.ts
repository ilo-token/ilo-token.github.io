// this code is Deno only

import { extractResultError, ResultError } from "../compound.ts";
import { PositionedError } from "../parser/parser_lib.ts";
import { parseDictionary } from "./parallel_parser.ts";
import { Dictionary } from "./type.ts";

const SOURCE = new URL("../../dictionary.txt", import.meta.url);
const DESTINATION = new URL("./global_dictionary.ts", import.meta.url);

export async function buildWithDictionary(
  dictionary: Dictionary,
): Promise<void> {
  const json = JSON.stringify(
    Object.fromEntries(dictionary),
    undefined,
    2,
  );
  const code = `\
// this code is autogenerated

import { Dictionary, Entry } from "./type.ts";

const json: Record<string, Entry> = ${json};

export const dictionary: Dictionary = new Map(Object.entries(json));
`;
  await Deno.writeTextFile(DESTINATION, code);
}
export async function build(): Promise<boolean> {
  // deno-lint-ignore no-console
  console.log(
    `Building dictionary with ${navigator.hardwareConcurrency} threads...`,
  );
  const start = performance.now();
  const text = await Deno.readTextFile(SOURCE);
  let dictionary: Dictionary;
  try {
    dictionary = await parseDictionary(text);
  } catch (error) {
    displayError(text, extractResultError(error));
    return false;
  }
  await buildWithDictionary(dictionary);
  const end = performance.now();
  const total = Math.floor(end - start);
  // deno-lint-ignore no-console
  console.log(
    `Building dictionary done in ${total}ms`,
  );
  return true;
}
function displayError(source: string, errors: ReadonlyArray<ResultError>) {
  let color: boolean;
  try {
    const noColor = Deno.env.get("NO_COLOR");
    color = noColor == null || noColor === "";
  } catch (error) {
    if (error instanceof Deno.errors.NotCapable) {
      color = true;
    } else {
      throw error;
    }
  }
  const red = color ? "color: red" : "";
  const sourceStyle = color ? "color: blue" : "";
  for (const error of errors) {
    // deno-lint-ignore no-console
    console.error(`%cError%c: ${error.message}`, red, "");
    if (error instanceof PositionedError && error.position != null) {
      const { position: { position, length } } = error;
      const end = position + length;
      // the only instance returning -1 is useful
      const startLine = source.lastIndexOf("\n", position) + 1;
      let currentLine = startLine;
      let currentPosition = position;

      while (true) {
        const index = source.indexOf("\n", currentLine);
        const nextLine = index === -1 ? source.length : index + 1;
        const line = source.slice(currentLine, nextLine).trimEnd();
        // deno-lint-ignore no-console
        console.error(line);
        let relativeStart = Math.min(
          currentPosition - currentLine,
          line.length,
        );
        let relativeEnd = Math.min(end - currentLine, line.length);
        if (relativeEnd - relativeStart === 0) {
          if (relativeStart !== 0) {
            relativeStart--;
          }
          if (relativeEnd !== line.length) {
            relativeEnd++;
          }
        }
        // deno-lint-ignore no-console
        console.error(
          `${" ".repeat(relativeStart)}%c${
            "^".repeat(relativeEnd - relativeStart)
          }`,
          red,
        );
        if (end <= nextLine) {
          break;
        } else {
          currentLine = currentPosition = nextLine;
        }
      }
      const line = source.slice(0, startLine).match(/\n/g)?.length ?? 1;
      const column = position - startLine + 1;
      // deno-lint-ignore no-console
      console.error(`    at %c${SOURCE}:${line}:${column}`, sourceStyle);
      // deno-lint-ignore no-console
      console.error();
    }
  }
}
if (import.meta.main) {
  Deno.exitCode = await build() ? 0 : 1;
}
